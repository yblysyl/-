https://www.bilibili.com/video/BV1hZ4y1i724 视频教学总结
缓存一致性原理	多核cpu缓存不一致时调用，为减少调用节约时间开销，将常用变量前后用64字节空空间包裹。
CPU重排		cpu会重新调整指令顺序保证此线程中的指令优化且不影响结果，但其他线程可能会因为此线程顺序调换出现异常。多线程必须考虑其他线程内部乱序问题。
javanew对象   	1、分配空间，空间所有内容赋0 2、调用构造函数，调用完毕后给内部变量赋值 3、将对象给引用
DCL单例 		双层校验 在进入加锁 synchronized 代码前后各进行一次校验判断 第一层提高效率；第二层防止线程错误问题。  synchronized 保障可见性和原子性
JVM内存屏障四种 	volatile 阻止线程内部乱序； volatile 保障有序性 实现细节：jvm会在volatile 修饰的变量前后加内存屏障；操作系统和cpu有相应的屏障指令（lockxxx）
引用	强引用	默认引用方式；当没有强引用指向对象，该对象将会被回收
	软引用	SoftReference; 当jvm内存不够的时候会被系统回收；可以用来做缓存数据
	弱引用	WeakReference；gc一运行便回收内存；ThreadLocal--保证线程内调用得所有方法可以访问到该对象，但其他线程不能访问到该对象（map绑定线程；k绑定对象自身）。弱引用解决强引用内部指向自己导致无法回收问题；ThreadLocal内部得map- k就是用弱引用指向对象自己。既能释放又能线程or对象唯一；ThreadLocal使用后一定要执行.romve 防止内存泄漏
	虚引用	管理堆外内存，对象被回收的时候通知jvm通过接口处理释放对外内存问题

线程与锁：
	synchronized	所有对象都可被锁。new object();空对象占16字节  对象标记（markword）八个字节，引用（类型指针class pointer）四个字节，数据0字节，补全对齐四个字节（补全保证对象大小一定为8的整数倍） synchronized对象原理，markword记录锁的信息、hashcode信息、垃圾回收器信息
	AtomicInteger 	对象；该对象为原子类型对象，能保证多线程不会共同修改.原理cas；类似的锁很多
	CAS比较并交换；	原理：读取当前值E,计算结果值V;比较E和当前新值N if相等 跟新新值V,else不相等 返回读取当前值E
		CAS问题 ABA问题-加版本号解决	；在比较之后写入之前其他线程修改问题，通过引入c,在c中引入汇编底层代码，以及加锁，硬件层面解决。
	轻量级锁、重量级锁。前者jvm处理，线程循环占用cpu资源；后者os处理，线程等待不占用cpu资源
	无锁、偏向锁、轻量级、重量级的区分标志位在markword中 

哲学家就餐问题	信号量、奇偶区分、一次性分配。
	线程相互叫醒问题。LockSupport.park()和LockSupport.unpark(t1)组合（a先叫醒b，后b阻塞自己,b仍能被叫醒）；wait，notifly不可以（旧有方法）；
	ReentrantLock对象	该对象可以通过Condition（一种队列）来实现叫醒某个队列，本线程去某个指定队列休息
	TransferQueue对象	一种队列，该队列的获取和放入都会阻塞线程，只有当获取到或者放入被拿走才会继续本线程；

分层细致化理念：
	在对象的方法或者类中，当处理某一类问题的时候；如果问题比较复杂或者要保证不同类、对象之间的一致性，可以进行分层，抽取；将要执行的工作的共同点放入一个方法作为独立的一层，不同点放入另一个方法被独立层调用。

如何理解线程池的7个参数?1.核心线程数；2.最大线程数；3.生存时间60；4.时间单位 秒；5.任务队列；6.线程工厂；7.拒绝策略。 核心线程数--一直存活的线程数量，当任务过多时，多余的任务将进入任务队列，当任务队列满时，激活线程数到最大线程数，当任务处理完毕，线程等待时间等于生存时间和时间单位组合，线程数量恢复到核心线程数。当线程巨量过多时，执行拒绝策略，多为将任务持久化、扔掉或者放入mq等等。线程工厂，对线程命名管理等。
	
